# -*- coding: utf-8 -*-
"""v13 Iterative Funelling Moondream2_Colab_Quickstart.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nl8srDb9A657usZ9njuJU57LH5tsIJnv
"""

pip install moondream

from google.colab import drive
drive.mount('/content/drive')

# Importing Necessary Libraries
import moondream as md
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
import numpy as np

# Initialize for Moondream Cloud
model = md.vl(api_key="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXlfaWQiOiI1MzE1ZDA0NS0yYzMyLTQ2ZjMtYmNlOS04YTE4MjQxMWQ4ZjgiLCJvcmdfaWQiOiI5ZTJ6bzdkQndUZGhRdk55Zkp0TjBscEpkOVQ4U2VmcyIsImlhdCI6MTc2MzM5MjA5MiwidmVyIjoxfQ.t0qq9hJscs5fk-gsPe1AiuPjMpmqovrFoz5lwPQRlvQ")

# defining the tolerance for bounding boxes
tol = 0.667
tol_IOU = 0.5

#--------------- getBoundingBoxArray --------------------------------------------

# given an image and a prompt, this will return an array of bounding boxes
def getBoundingBoxArray(input_image,prompt):
  img_width = input_image.width
  img_height = input_image.height
  detect_output = model.detect(input_image, prompt)["objects"]
  for obj in detect_output:
    obj["x_min"] *= img_width
    obj["y_min"] *= img_height
    obj["x_max"] *= img_width
    obj["y_max"] *= img_height
  return detect_output

#--------------- IntersectionOverUnion -----------------------------------------

# calculating the area of intersection over the area of the union when given two
# sets of points that define bounding boxes
def IntersectionOverUnion(x_min, x_max, y_min, y_max,
                          x2_min, x2_max, y2_min, y2_max ):
  areaOverlap = max(0,(min(x_max, x2_max) - max(x_min, x2_min))) * max(0,(min(y_max, y2_max) - max(y_min, y2_min)))
  areaUnion = (x_max - x_min) * (y_max - y_min) + (x2_max - x2_min) * (y2_max - y2_min) - areaOverlap
  return areaOverlap/areaUnion

#--------------- filterBoundingBoxes -------------------------------------------

# filters a list of bounding boxes so that it doesnt include very large ones
# that take up the entire screen or any that contain entire other ones or any
# that overlap too much on previous bounding boxes
def filterBoundingBoxes(unfiltered_boxes ,input_image, boxes):

  img_width = input_image.width
  img_height = input_image.height
  filtered_boxes = []

  for unfiltered_box in unfiltered_boxes:

    x_min = unfiltered_box["x_min"]
    x_max = unfiltered_box["x_max"]
    y_min = unfiltered_box["y_min"]
    y_max = unfiltered_box["y_max"]

    remove  = False

    # Cutting out large bounding boxes
    if (abs(x_min- x_max)/img_width > tol or abs(y_min-y_max)/img_height > tol):
      print("Oops.  big bounding box")
      remove = True

    # Checking if it overlaps with any of the other bounding boxes
    for box in boxes:
      x2_min = box["x_min"]
      x2_max = box["x_max"]
      y2_min = box["y_min"]
      y2_max = box["y_max"]

      IOU = IntersectionOverUnion(x_min, x_max, y_min, y_max,
                               x2_min, x2_max, y2_min, y2_max)
      if  IOU > tol_IOU:
        print("Oops.   repeated bounding box")
        remove = True

    # If we have no reason to remove the bounding boxes, then we append
    if not remove:
      filtered_boxes.append(unfiltered_box)

  return filtered_boxes

#--------------- drawBoundingBoxesFill  ----------------------------------------

# draws filled rectangles for the bounding boxes on a given ImageDraw object
# return the number of
def drawBoundingBoxesFill(drawObject, outlineColor, fillColor, bounding_boxes):
  for box in bounding_boxes:
    drawObject.rectangle( [(box["x_min"], box["y_min"]),
                           (box["x_max"], box["y_max"])],
    outline = outlineColor,
    width = 1,
    fill = fillColor )
  return len(bounding_boxes)

#--------------- drawBoundingBoxes ---------------------------------------------

# draws bounding boxes but does not fill them for a given ImageDraw object
def drawBoundingBoxes(drawObject, outlineColor, bounding_boxes):
  for box in bounding_boxes:
    drawObject.rectangle( [(box["x_min"], box["y_min"]),
                           (box["x_max"], box["y_max"])],
    outline = outlineColor,
    width = 3)

#--------------- newBoundings --------------------------------------------------

# Detect objects in the image
def newBoundings(input_image, prompt, image_draw, empty_draw,
                 fillColor, outlineColor, image, boxes):

  unfiltered_boxes = getBoundingBoxArray(input_image, prompt)
  new_boxes = filterBoundingBoxes(unfiltered_boxes, input_image, boxes)

  print(len(new_boxes))

  drawBoundingBoxesFill(image_draw, fillColor, fillColor, new_boxes)
  drawBoundingBoxes(empty_draw, outlineColor, new_boxes)

  return new_boxes

# Creating pairs of the image name and what we are searching for
pairs = []
pairs.append(("aphids", "bugs"))          # 0
pairs.append(("medicine", "pills"))       # 1
pairs.append(("apples", "apples" ))       # 2
pairs.append(("apples2", "apples" ))      # 3
pairs.append(("port", "boat" ))           # 4
pairs.append(("flies", "bug" ))           # 5
pairs.append(("medicine2", "pills" ))     # 6

#The fill color of the boxes
fillColor = "black"

improvementPairs = []

for search_num in range(0, len(pairs)):

  # 1. Accessing the file name and what we are searching for
  name = pairs[search_num][0]
  search = pairs[search_num][1]
  print(f"IMAGE: {name}.png")

  # 2. Opening up the image from the source file
  img_source= f"/content/drive/MyDrive/DRP 2025/Images/{name}.png"
  image = Image.open(img_source)

  # A list of colors to seperate each iterative bounding box run
  color_list = ['red', 'orange', 'yellow', 'blue', 'purple']
  prevBoxes = []

  # 3. Create images
  img = Image.open(img_source).convert("RGB")      # prev. detected boxes are black
  visual = Image.open(img_source).convert("RGB")   # visualize boxes by location

  # 4. Create drawing objects
  draw = ImageDraw.Draw(img)
  visual_draw = ImageDraw.Draw(visual)

  # 5. Repeating this for up to 5 gens and stopping if no new objs are detected
  for generation in range(1,5):
    print(f"Generation: {generation}")
    color = color_list[generation-1]

    new_boxes = newBoundings(img, search, draw, visual_draw, fillColor, color,
                            image, prevBoxes)
    value = len(new_boxes)

    if generation == 1:
      initial = value

    if value == 0:
      final = len(prevBoxes)
      improvementPairs.append( (initial, final) )
      break

    for adds in new_boxes:
      prevBoxes.append(adds)

  # 4. Save the resulting image
  output_path = "/content/drive/MyDrive/DRP 2025/Output_Images/"+ name + "Detected.png"
  visual.save(output_path)
  print(f"Bounding box overlay saved to: {output_path}")

pairsData = np.asarray(pairs)
comparisonData = np.asarray(improvementPairs)
names = pairsData[:,0]
initial_values = comparisonData[:,0]
final_values = comparisonData[:,1]

# Label locations and bar width
x = np.arange(len(names))
width = 0.35

# Create the plot
fig, ax = plt.subplots(figsize=(10, 6))
rects1 = ax.bar(x - width/2, initial_values, width, label='Initial Count', color='#3b8dcc')
rects2 = ax.bar(x + width/2, final_values, width, label='Final Count', color='#ff7f0e')

# Add labels and title
ax.set_ylabel('Object Count')
ax.set_title('Comparison of Object Detection Counts: Initial vs. Final')
ax.set_xticks(x)
ax.set_xticklabels(names)
ax.legend()

# Add value labels on top of bars
ax.bar_label(rects1, padding=3)
ax.bar_label(rects2, padding=3)

fig.tight_layout()

# Save and show the chart
plt.savefig("/content/drive/MyDrive/DRP 2025/Output_Images/_comparison_chart.png")

total_initial = np.sum(initial_values)
total_final = np.sum(final_values)
percent_increase = (total_final/total_initial - 1)*100
print(f"Total initial count: {total_initial}")
print(f"Total final count: {total_final}")
print(f"Total percent increase: {percent_increase:.2f}%")

print()

mean_increase = np.mean(final_values - initial_values)/np.mean(initial_values)*100
print(f"Average percent increase: {np.mean(initial_values):.2f}%")

